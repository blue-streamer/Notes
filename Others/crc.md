### crc算法

crc是一种校验值，这个校验值可以附加在一串数据后来校验这些数据是否被修改。

crc本质上是一个二进制“模2”的除法，原始数据为被除数，crc生成多项式为除数，crc值为余数。其中整个模2的除法是指其中涉及到加减法都无需进位和借位。这样加减法就变成了异或运算。

因此crc校验算法都需要一个生成多项式作为除数，例如crc-8的生成多项式为：x^8 + x^5 + x^4 + x^0，因此对应的除数为100110001。crc的生成多项式有一个位宽（W）的概念，这个位宽是生成多项式位数-1，多项式的首位肯定是1，因此可以统一去掉，交流方便。

在进行运算时，待校验的数据需要末尾补充W个0，然后进行模2除法来获得余数。当余数附加在原始数据之后则正好可以被整除。因此，接收端收到数据之后只需要判断是否被整除即可。

常用的奇偶校验就是两种不同的crc1，生成多项式为x^1 和 x^1 + x^0。

crc的除数一般都是经过特殊设计的，这样碰撞的概率很小。一般使用经典的crc就可以

### crc实现

在使用crc计算校验值时，通常会对原有的算法进行改进。这是因为这种最基本的CRC除法有个很明显的缺陷，就是数据流的开头添加一些0并不影响最后校验字的结果。所谓的改动，也就是增加了两个概念，第一个是“余数初始值”，第二个是“结果异或值”。

所谓的“余数初始值”就是在计算CRC值的开始，给CRC寄存器一个初始值。“结果异或值”是在其余计算完成后将CRC寄存器的值在与这个值进行一下异或操作作为最后的校验值。

具体可以参考  https://blog.csdn.net/liyuanbhu/article/details/7882789

### crc快速算法

上面的crc计算比较慢，因为要一个bit一个bit的计算。因此，有了基于查表的快速算法。查表的算法可以按照需求自己定义，可以是半个字节，单字节或者双字节。原理都是一样的，异或可以看做加减。高位的余数右移然后和低位相加（异或）得到新的待计算的被除数，然后查表得到结果。

使用crc-8可以建立单字节的表格，crc-16可以建立双字节的表格。这个计算最为简单

https://blog.csdn.net/u012993936/article/details/45339983