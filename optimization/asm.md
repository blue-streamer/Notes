## x86 asm

### 寄存器

- 8个32位通用寄存器包括：EAX、EBX、ECX、EDX、ESP、EBP、EDI、ESI，EFlags，EIP。 此八个寄存器的16位表示形式就是去掉前面的E：AX，BX，CX，DX，SP，BP，DI，SI，Flags，IP。对于EAX、EBX、ECX、EDX分别还有它们的8位形式：AH、AL、BH、BL、CH、CL、DH、DL。6个16位段寄存器包括：CS、DS、ES、SS、FS、GS。然后还有两个EIP指令指针和EFLAGS标志寄存器
- 浮点寄存器：ST(0),ST(1),ST(2),ST(3),ST(4),ST(5),ST(6),ST(7),  0-79bit
- 64位的 MMX 寄存器总共有8个，从MM0到MM7   0-63bit。**由于这8个MMX寄存器与8个80位的浮点寄存器共用**，所以在程序中切换MMX运算和浮点运算的时候需要使用**EMMS**指令，由于切换效率比较低，故代码中应尽量减少这种切换。这也是intel设计的缺陷之一，所以在增加了XMM寄存器时，就没有和任何已有的寄存器共用。
- 128位的 XMM 寄存器 8个，从XMM0 到 XMM7
- 256位的 YMM 寄存器 8 个， YMM0 到 YMM7
- 512位的 ZMM 寄存器 8 个，ZMM0 到 ZMM7

### 栈

x86的架构中栈是从高地址向低地址生长的，esp寄存器始终保存着栈顶的指针。push和pop指令都会自动修改esp的值，push指令的具体操作如下：

**首先使esp的值减4(由于栈是向低地址生长)，然后把对应的值写入esp指向的内存。**

因此esp永远指向栈顶存储最新压栈数据的地址，如果想要访问之前压栈的数据，使用esp+n即可寻址

### 调用规范

x86的汇编需要注意调用规范，所有符合这个规范高级语言编写的函数都可以相互调用。

```c
void caller(int a，int b)
{
  a = a + b;
	b = callee(a,b);
  return a + b;
}
```

调用规范分为**调用者规范**和**被调用者规范**，如示例代码中的caller函数称为调用者，callee函数称为被调用者。所谓调用者规范是指在调用函数之前和调用函数返回之后，除了函数逻辑外额外需要做的事情。所谓被调用者规范是指被调用的函数进入之后和返回之前，除了函数逻辑外额外需要做的事情。这些规范，保证了参数传递，寄存器保护，返回值的传递等等。

当我们使用高级语言时，这些事情编译器会帮我们生成相关的代码来完成。如果是使用汇编需要，则需要程序员自己完成

#### caller规范-调用前：

1. 保护寄存器eax，ecx，edx。把这些寄存器的值压栈。

2. 将调用函数的参数压栈，按照从右到左的顺序。如上，先压栈b，再压栈a。

3. 使用call指令，使程序跳转到callee的入口地址。此时，call指令会把当前的地址，即callee执行完的返回地址压栈

![stack1](asm.assets/stack1-2327933.png)

#### callee规范-调用后：

1. 压栈保存ebp的值，此时ebp的值是caller函数中的ebp。

2. 压栈保护寄存器ebx，edi，esi。

3. esp的值赋值给ebp，此时ebp中的值为callee的栈基指针。callee返回时会使用这个指针来清理栈上的局部变量，变成调用之前的情况。

![stack2](asm.assets/stack2.png)

#### callee规范-返回前：

1. 返回值放入eax中。

2. 清除栈上的局部变量，即mov esp，ebp。注意，在callee中不要去修改ebp的值，此时需要使用ebp来清除栈上的局部变量。

3. 弹栈恢复ebx，edi，esi。

4. 弹栈恢复ebp的值，此时ebp是caller中的ebp。当caller返回时，需要使用ebp来清除栈上的局部变量。

5. 执行ret指令返回

#### caller规范-返回后：

1. 获取eax中的返回值

2. 清除调用callee时栈上的参数

3. 弹栈恢复eax，ecx，ebx的值

注意，如果callee中不会使用到栈，或者短暂使用栈随后马上清除，则此时不需要操作ebp。ebp只是一个习惯于被用于保存栈基地址的寄存器，当然也可以作为通用寄存器使用