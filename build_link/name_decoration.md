c/c++源文件通过编译生成目标文件，目标文件通过连接生成可执行文件或者动态链接库。链接器的一个重要作用是完成符号决议，把外部文件的函数调用或者全局函数引用地址绑定。每个需要符号决议的函数或者变量在生成的目标文件中都有对应的符号，目标文件中符号和源文件的中的符号有一些区别，这个符号的变化称为**名称修饰**（Name-decoration）。不同**调用约定**和**编译语言**会有不同的名称修饰的方式。

重要的是，在链接过程中，如果符号的调用者和符号的提供者在编译过程中使用了不同的名称修饰规则，则会出现找不到符号的链接错误。通常在链接使用第三方库容易出现这个错误。

### 调用约定

调用约定主要规定了函数调用时的规则，例如参数入栈顺序，栈恢复的规则等等。同时也规定的名称修饰的方式。常见的调用约定如下：cdecl，stdcall，fastcall，vectorcall等等。这里我们只关心调用约定中的名称修饰，例如函数void func(int,int)

- cdecl: 函数名称之前加下划线，_func
- stdcall: 函数名称之前加下划线，后面加@和参数大小，_func@8
- fastcall: 函数名称之前加@，后面加@和参数大小，@func@8
- vectorcall: 函数名称之后加@@和参数大小，func@@

上述的名称修饰时c编译器生成的，对于c++由于支持函数重载，使用了更复杂的名称修饰规则。例如c++的cdecl：?func@@YAXHH@Z。注意，**对于x64的架构，cdecl的名称修饰没有前置下划线**。

### 如何指定调用约定

代码编译时会通过编译选项来指定调用约定，默认使用cdecl。可以通过编译选项来指定，如vc编译器 /Gv(vectorcall)，/Gz(stdcall)，/Gr(fastcall)，/Gd强制使用cdecl。在函数声明时，函数名之前添加对应的修饰符可以指定该函数使用的调用约定。例如，void _stdcall func(int, int)。使用extern "C"修饰的代码段，在c++编译中会使用c的编译规则。

函数调用者生成符号的名称修饰，是由编译当前源文件时看到的函数声明和当时使用的编译选项决定的。因此，可以通过修改头文件来改变调用者所需符号的名称修饰。

