### Encoder entrance 

CCtuEncTask::execute()

### Ctu entrance

CCtuEnc::processOneCtu()

### function pointer

initSCCFunctions:

g_calcSccUniform2x2_func = calcUniformgenius2x2;

g_calcSccUniformRow_func = calcUniformRow;

g_calcSccUniformCol_func = calcUniformCol;

g_calcSccUniformMask_func = calcUniformMask;

g_fastCrcNormal8x8_func = fastcrc32_c;

g_getHashIdx_func = getHashIdx



pfProcessCuMd --> processCuMdIntra/processCuMdInter

pfMotionSearch --> motionSearchP/motionSearchB



### defaultParam

enSkipCU16Above, 0: normal processing, 1: enable skip16 processing，skip 64x64 and 32x32 cu size(0 and 1 depth)

iEarlySkipCheckCUD, 0:disable; 1b(flag) + 1b(TL0) + temporal_level: enable minimal cu depth restriction for early skip. b0: enable or disable

bOnlySkipForLargeCU: false, only check skip mode for large CU sizes

enUp2DownJudgeByMaxDepth: true

enMergeTuDecision: false, enable merge tu decision

bFastInit: false, fast Ctu/Cu initialization

iMergSADTh: 0, threshold of mergeSAD for fast choosing merge as the better mode rather than inter, and skipping ME

enUp2DownJudgeByMaxDepth: 1

iTreePartFast: 0, 0:disable; 1: enable fast subPart; 2: enable fast encoding for current cu according to cu depth; 3: both

cuGoUpLevel: 0, 0: veryfast; 1: medium; 2: full; (< 2: enable fast do bigger cu when going down to up)

bOnlySkipForLargeCU: false, only check skip mode for large CU sizes

### TCtuInfo

ctu 中cu通过链表管理，头结点不存储有效信息cuHead，pCuTail指向当前cu，尾插更新链表。pCuTail初始化为&cuHead。这个链表的顺序是按照划分决策之后的zigzag遍历顺序

cu_group中是预分配好的cu，85个（1+4+16+64），并且分配到cu->subcu中，已完成初始化

iEearlyStop[4] 存储每个depth是否skip

### cu

TPredUnit* pu[8]，每个元素都是数组首地址，代表了8中pu的划分方式。2nx2n有一个元素，nxn有4个元素

processCuMdInter

​	tryMerge2Nx2N

​	checkInterPu2Nx2N

​		pfMotionSearch

​			motionSearchL0

​		tuDecision，选择最佳的tu深度。选择过程并没有递归遍历，只是遍历了不同的深度。选择除了最佳深度

​	有条件去try 另外的pu size

​	may ibc

​	may rdoq

​	intraMD



### ProcessTree

initCuOnMdStart

pfEarlySkip



Todo:

storeCodingParam/storeNborInfo





cu的深度预测是通过left，top，topRight，topLeft的深度加权预测得到的，3：3：2：2